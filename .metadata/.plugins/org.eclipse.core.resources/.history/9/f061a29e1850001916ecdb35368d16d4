// --------------------------------------------------------
// Code generated by Papyrus Java
// --------------------------------------------------------

package MAE1Project;

//------------------ IMPORT MODULES ---------------------------//

//No modules to import

/************************************************************/
/**
 * Class Encounter is in charge of commanding the dynamics of
 * any confrontation between two teams.
 */
public class Encounter {
	
	// ------------------ PROPERTIES ------------------------ //

	/**
	 * teamHero is a Team instance for the
	 * Heroes in the confrontation.
	 */
	private Team<Hero> teamHero;
	
	/**
	 * teamMonster is a Team instance for the
	 * Monster in the confrontation.
	 */
	private Team<Monster> teamMonster;

	/*
	 * ui is the UI instance required to perform the command.
	 */
	public UI ui;
	
	//----------------------- METHODS ---------------------------//

	/**
	 * Class constructor
	 * @param teamHero: Team of heroes
	 * @param teamMonster: Team of monsters
	 */
	public Encounter(Team<Hero> teamHero, Team<Monster> teamMonster) {
		// Set the properties of the object
		this.setTeamHero(teamHero);
		this.setTeamMonster(teamMonster);
		this.setUi(UI.INSTANCE);
	}
	
	/**
	 * runEncounter is the method which accounts for executing the
	 * encounter between the two parties.
	 */
	public void runEncounter() {
		// First Print to Screen the Encounter
		this.presentEncounter();
		
		// Initialize a counter to keep track of the encounter
		int counter = 0;
		
		// Run the encounter
		while (!isFinished) 
		{
			// If even run Turn for the Hero team
			if (counter % 2 == 0){
				// Create newTurn and run it
				Turn<Hero, Monster> newTurn = new Turn<Hero, Monster>(teamHero, teamMonster, true);
				newTurn.runTurn();
			}
			else {
				// draft monster following participation Queue
				// TODO: implement TypeException Exception handling
				Monster monster = teamMonster.draftMember();
				// Create newTurn and run it
				Turn<Monster, Hero> newTurn = new Turn<Monster, Hero>(monster, teamMonster, teamHero);
				newTurn.runTurn();
			}
			
			// Update both teams
			teamHero.update();
			teamMonster.update();
			
			// Update isFinished
			
		}
	}
	
	/**
	 * presentEncounter() is a private method which handles the presentation
	 * of the objects at the beginning of the Encounter.
	 */
	private void presentEncounter() {
		// Collect both teams strings and merge them accordingly
		String out = "";
		out += "\n------------------- NEW FIGHT!!!!! GET READY!!!!!! ----------------------\n";
		out += "Featuring: \n";
		out += this.getTeamHero().toString();
		out += "\n\n VERSUS \n\n";
		out += this.getTeamMonster().toString();
		out += "\n------------------- LET THE FIGHT TO DEATH BEGIN!!!! ---------------------\n";
		
		// Print the object to the screen
		this.getUi().printToScreen(out);
	}
	
	/**
	 * runNewTurnHero implements the Turn for the Hero
	 */
	
	/***************** GETTERS AND SETTERS ******************/

	public boolean isWon() {
		return !(teamHero.getMembers().isEmpty());
	}

	public boolean isFinished() {
		return isFinished;
	}

	public void setFinished() {
		this.isFinished = (teamHero.getMembers().isEmpty() || teamMonster.getMembers().isEmpty());
	}

	public Team<Hero> getTeamHero() {
		return teamHero;
	}

	public void setTeamHero(Team<Hero> teamHero) {
		this.teamHero = teamHero;
	}

	public Team<Monster> getTeamMonster() {
		return teamMonster;
	}

	public void setTeamMonster(Team<Monster> teamMonster) {
		this.teamMonster = teamMonster;
	}

	public UI getUi() {
		return ui;
	}

	public void setUi(UI ui) {
		this.ui = ui;
	}
	
	
};
